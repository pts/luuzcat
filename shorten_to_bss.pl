#
# shorten_to_bss.pl: move trailing NUL bytes of _DATA to _BSS, shortening the file
# by pts@fazekas.hu at Sun Oct 19 14:22:24 CEST 2025
#

BEGIN { $^W = 1 }
use integer;
use strict;
die("Usage: $0 <prog.com>\n") if @ARGV != 1;
my $fn = $ARGV[0];
my $fnoq = ($fn =~ m@^[\w/]@) ? $fn : "./$fn";  # Escape for Perl open.
die("fatal: open: $fn\n") if !open(F, "+< $fnoq");
my $s;
die("fatal: error reading DOS .com program: $fn\n") if (sysread(F, $s, 0xff00) or -1) < 0;
die("fatal: DOS .com program too short: $fn\n") if length($s) < 1;
# PSP (0x100 bytes) + DOS .com program code+data (<=0xfe80 bytes) + stack (>=0x60 bytes) <= 0x10000 bytes == 64 KIB.
die("fatal: DOS .com program too long: $fn\n") if length($s) > 0xfea0;
if ($s =~ m@^\x33\xc0(\xbf)(..)\xb9(..)\x2b\xcf\xf3\xaa@s or  # xor ax, ax ++ mov di, ... ++ mov cx, ... ++ sub cx, di ++ rep stosb.
    $s =~ m@^\x33\xc0\x90(\x90)\xbf(..)\xb9(..)\xf3\xaa@s or  # xor ax, ax ++ nop ++ nop ++ mov di, ... ++ mov cx, ... ++ rep stosb.
    $s =~ m@^\x33(\xc0)\xbf(..)\xb8(..)\xf3\xaa@s) {  # xor ax, ax ++ mov di, ... ++ mov ax, ... ++ rep stosb.  Deliberately incorrect by _DOSCOMSTART_DISTART.
  my $is_distart = $1 eq "\xc0";  # We'll fix this deliberately incorrect code generated by __DOSCOMSTART_DISTART (`mov ax, ...' should be `mov cx, ...') later.
  my $bss_start = unpack("v", $2); my $bss_end = unpack("v", $3);
  $bss_end += $bss_start if $1 eq "\x90";
  die("fatal: bad _bss_start in DOS .com program: $fn\n") if $bss_start != length($s) + 0x100;
  die("fatal: bad _bss_end in DOS .com program: $fn\n") if $bss_end < $bss_start or $bss_end > 0xffa0;
  my $i = length($s);
  while (!vec($s, --$i, 8)) {}  # Skip backward over trailing NULs.
  $i = length($s) - 1 - $i;  # This sets $i to the number of NUL bytes to remove from the end of $s. It can also be 0.
  my $code = pack("a*a*va*va*", $is_distart ? "\x33\xc0" : "\x33\xc0\x90\x90", "\xbf", $bss_start - $i, "\xb9", $bss_end - $bss_start + $i, "\xf3\xaa");
  die("fatal: error seeking to start: $fn\n") if (sysseek(F, 0, 0) or -1) != 0;
  die("fatal: error writing to DOS .com program: $fn\n") if (syswrite(F, $code, length($code)) or 0) != length($code);
  die("fatal: error truncating DOS .com program: $fn\n") if !truncate(F, length($s) - $i);
} else {
  die("fatal: unsupported DOS .com program start code: $fn\n");
}

__END__
