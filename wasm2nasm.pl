#
# wasm2nasm.pl: convert wdis(1) `wdis -a -fi -fu -i=@' disassembly from WASM to NASM syntax
# by pts@fazekas.hu at Mon Oct 13 03:35:21 CEST 2025
#
# Currently only the output of wcc386 (OpenWatcom C compiler, i386 target)
# is supported. Tested only with a limited subset.
#

BEGIN { $^W = 1 }
use integer;
use strict;
my $secname_const = "CONST";  # String literals.
shift(@ARGV), $secname_const = $1 if @ARGV and $ARGV[0] =~ m@^--CONST=(.*)@s;  # Example: --CONST=_TEXT
my $fi = int($ARGV[0]); die("fatal: bad or missing file index argument: $fi\n") if !$fi;  # File index.
my $ofs;
my %globals;  # Symbol names to be prefixed with "G\@".
my %locals;  # Explicitly defined symbol names (e.g. for C static globals) to be prefixed with "L\@$fi\@".
my @lines;
my $cpu;
my $bits = 16;
while (<STDIN>) {
  chomp;
  die("fatal: unexpected characters in WASM line: $_\n") if y@\x00-\x08\x0a-\x1f\x7f-\xff\x27"~`\\;!^=\#%&/|<>?(){}@@ and  # Allow "\@\$digit".
      !m@^(?:_TEXT|CONST2?|_DATA|_BSS|YI[BE]?)\s+SEGMENT\t@;  # Allow 'CODE' etc. in segment declaration.
  $locals{$1} = 1 if m@^([_a-zA-Z]\w*)(?::|\s+LABEL\s)@;
  $cpu = $1 + 0 if m@^[.]([1-6]86)@;
  $bits = 32 if m@^_TEXT\s+SEGMENT[ \t]@ and m@[ \t]USE32\b@;
  push @lines, $_;
}
$cpu = ($bits == 32) ? 386 : 8086 if !defined($cpu);
print("; NASM source file autogenerated by wasm2nasm.\nCPU $cpu\nBITS $bits\n");
# We must not emit the section definitions (i.e.
# `print($nasmcode_sectiondef)') just yet, because we want to emit the
# EXTERNs first. If we don't emit the EXTERNs first, then, from this .nasm
# source file, NASM (`nasm -f obj') will generate an OMF .obj file which
# OpenWatcom wlink(1) will misunderstand, and generate incorrect offsets
# when EXTERN symbols are used in an instruction. Here is the difference, as
# indicated in the output of `wdis -a -fi -fu':
#
# * bad:  MOV byte ptr [ESI+_TEXT:`G@myglobalvar`],AL
# * good: MOV byte ptr [ESI+`G@myglobalvar`],AL
#
# We work this around (i.e. we change it from bad to good) by moving the
# first `SECTION' definition later than the last `EXTERN' in this .nasm file.
# We do so by delaying the `print($nasmcode_sectiondef)'.
my $nasmcode_sectiondef = ($bits == 32) ? qq(
%ifdef PROG_SECTIONS_DEFINED
%elifidn __OUTPUT_FORMAT__, obj  ; For OpenWatcom wlink(1).
  section _TEXT  USE32 class=CODE align=1
  section CONST  USE32 class=DATA align=1
  section CONST2 USE32 class=DATA align=4
  section _DATA  USE32 class=DATA align=4
  section _BSS   USE32 class=BSS  align=4 NOBITS
  group DGROUP CONST CONST2 _DATA _BSS
  section _TEXT
%elifidn __OUTPUT_FORMAT__, elf  ; For GNU ld(1). Untested.
  %define _TEXT .text
  %define CONST .rodata.str
  %define CONST2 .rodata
  %define _DATA .data
  %define _DATAUNA .data.una
  %define _BSS  .bss
  section .text align=1
  section .rodata.str align=1
  section .rodata align=4
  section .data align=4
  section .data.una align=1
  section .bss align=4 nobits
  section .text
%endif\n\n) : qq(
%ifidn __OUTPUT_FORMAT__, obj  ; For OpenWatcom wlink(1).
  section _TEXT  USE16 class=CODE align=1
  section CONST  USE16 class=DATA align=1
  section CONST2 USE16 class=DATA align=2
  section _DATA  USE16 class=DATA align=2
  section _BSS   USE16 class=BSS  align=2 NOBITS
  group DGROUP CONST CONST2 _DATA _BSS
  section _TEXT
%endif\n\n);
for $_ (@lines) {
  if (s@^\t(?!\t)@@) {  # Assembly instructions in _TEXT.
    die("bad quote: $_\n") if m@["\x27]@;
    s@\s+@ @g; s@\b(?:FLAT|DGROUP):@@g; s@\@\$(\d+)\b@L\x40$fi\x40$1@g; s@,(?! )@, @g;
    s@\b(byte|d?word) ptr ds:\[@\U$1\E [@g;  # A small ds: can be omitted, it's the default.
    s@\b(byte|d?word) ptr ([CDEFGS]S:)\[@\U$1\E [$2@g;
    s@\b(byte|d?word) ptr (\w[^,]*)@\U$1\E [$2]@g;
    s@\b(byte|d?word) ptr (?=\[)@\U$1\E @g;
    s@\boffset @@g;
    if (m@^(CALL|JMP) near ptr (L\@\d+\@\d+|[_a-zA-Z]\w*)$@) { $_ = "$1 $2" }
    s@\b([_a-zA-Z]\w*)(?!\@)@ exists($globals{$1}) ? "G\x40$1" : exists($locals{$1}) ? "L\x40$fi\x40$1" : $1 @ge;
    #else { die("bad instruction: $_\n") }
    die("fatal: unexpected characters in output line: $_\n") if y@\x27"~`\\;!^=#\$%&/|<>?(){}@@;
    print("\t\t", $_, "\n");
  } elsif (m@^\t\t@) {
    if (m@^\t\tPUBLIC\s+([_a-zA-Z]\w*)$@) { $globals{$1} = 1; print("GLOBAL G\@$1\n") }
    elsif (m@^\t\tEXTRN\s+([_a-zA-Z]\w*):@) { $globals{$1} = 1; print("EXTERN G\@$1\n") }
    elsif (m@^\t\tASSUME\s+@) {}
    elsif ($_ eq "\t\tEND") {}
    else { die("bad: $_\n") }
  } else {
    if (m@^([_a-zA-Z]\w*)(?::|\s+LABEL\s)@) { print(exists($globals{$1}) ? "G\@$1:\n" : exists($locals{$1}) ? "L\@$fi\@$1:\n" : "$1:\n") }
    elsif (m@^\@\$(\d+)(?::|\s+LABEL\s)@) { print("L\@$fi\@$1:\n") }
    elsif (m@^    D[BWD]\s+@) { s@^\s+@\t\t@; die("bad quote: $_\n") if m@["\x27]@; if (s@\boffset (?:FLAT:)?@@g) { s@\@\$(\d+)\b@L\x40$fi\x40$1@g; s@\b([_a-zA-Z]\w*)(?!\@)@ exists($globals{$1}) ? "G\x40$1" : exists($locals{$1}) ? "L\x40$fi\x40$1" : $1 @ge }
        die("fatal: unexpected characters in output line: $_\n") if y@\x27"~`\\;!^=\#\$%&/|<>?(){}@@;
        print($_, "\n") }
    elsif (m@^    ORG\s+(\d[\da-f]*)(H?)@) { die("bad ofs: $_\n") if !defined($ofs); my $oldofs = $ofs; $ofs = $2 ? hex($1) : int($1); print("\t\tRESB $oldofs\n") if ($oldofs = $ofs - $oldofs) > 0; }
    elsif (m@^DGROUP\s+GROUP\s@) {}
    elsif (m@^(_TEXT|CONST2?|_DATA|_BSS)\s+SEGMENT\s@) { my $secname = $1; $secname = $secname_const if $secname eq "CONST"; print($nasmcode_sectiondef, "SECTION $secname\n"); $nasmcode_sectiondef = ""; $ofs = 0 if $secname eq "_BSS" }
    elsif (m@^[_A-Z0-9]+\s+ENDS$@) { $ofs = undef }
    elsif ($_ eq ".387" or $_ eq ".386p" or $_ eq ".model flat" or !length($_) or m@^YI[BE]?\s+SEGMENT\s@) {}
    else { die("bad: $_\n") }
  }
}
print($nasmcode_sectiondef);
