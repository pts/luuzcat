#
# shorten_to_bss.pl: move trailing NUL bytes of _DATA to _BSS, shortening the file
# by pts@fazekas.hu at Sun Oct 19 14:22:24 CEST 2025
#

BEGIN { $^W = 1 }
use integer;
use strict;
die("Usage: $0 <prog.com>\n") if @ARGV != 1;
my $fn = $ARGV[0];
my $fnoq = ($fn =~ m@^[\w/]@) ? $fn : "./$fn";  # Escape for Perl open.
die("fatal: open: $fn\n") if !open(F, "+< $fnoq");
my $s;
die("fatal: error reading DOS .com program: $fn\n") if (sysread(F, $s, 0xff00) or -1) < 0;
die("fatal: DOS .com program too short: $fn\n") if length($s) < 1;
# PSP (0x100 bytes) + DOS .com program code+data (<=0xfe80 bytes) + stack (>=0x60 bytes) <= 0x10000 bytes == 64 KIB.
die("fatal: DOS .com program too long: $fn\n") if length($s) > 0xfea0;
if ($s =~ m@^[\x33\x31]\xc0(\xbf)(..)\xb9(..)\x2b\xcf\xf3([\xaa])@s or  # xor ax, ax ++ mov di, ... ++ mov cx, ... ++ sub cx, di ++ rep stos[bw].
    $s =~ m@^[\x33\x31]\xc0\x90(\x90)\xbf(..)\xb9(..)\xf3([\xaa\xab])@s or  # xor ax, ax ++ nop ++ nop ++ mov di, ... ++ mov cx, ... ++ rep stos[bw].
    $s =~ m@^[\x33\x31](\xc0)\xbf(..)\xb8(..)\xf3([\xaa])@s or  # xor ax, ax ++ mov di, ... ++ mov ax, ... ++ rep stosb.  Deliberately incorrect by _DOSCOMSTART_DISTART.
    $s =~ m@^([\x33\x31])\xc0\xbf(..)\xb9(..)\xf3([\xaa\xab])@s) {  # xor ax, ax ++ mov di, ... ++ mov cx, ... ++ rep stos[bw]. Already fixed short version.
  my $is_short = ($1 eq "\xc0" or $1 eq "\x33" or $1 eq "\x31");  # We'll fix this deliberately incorrect code generated by __DOSCOMSTART_DISTART (`mov ax, ...' should be `mov cx, ...') later.
  my $is_word = ($4 eq "\xab") ? 1 : 0;
  my $is_delta = ($1 eq "\x90" or $1 eq "\x33" or $1 eq "\x31");
  my $bss_start = unpack("v", $2); my $bss_end = unpack("v", $3);
  $bss_end = $bss_start + ($bss_end << $is_word) if $is_delta;
  die("fatal: unaligned _bss_start in DOS .com program: $fn\n") if $bss_start & 1;
  die("fatal: bad _bss_start in DOS .com program: $fn\n") if $bss_start != ((length($s) + 1) & ~1) + 0x100;
  die("fatal: bad _bss_end in DOS .com program: $fn\n") if $bss_end < $bss_start or $bss_end > 0xff40;  # 0xc0 reserved for the stack, based on https://retrocomputing.stackexchange.com/a/31813
  my $i = length($s);
  while (!vec($s, --$i, 8)) {}  # Skip backward over trailing NULs.
  $i = length($s) - 1 - $i;  # This sets $i to the number of NUL bytes to remove from the end of $s. It can also be 0.
  my $code = pack("a*a*va*va*", $is_short ? "\x33\xc0" : "\x33\xc0\x90\x90", "\xbf", ($bss_start - $i + 1) & ~1, "\xb9", ($bss_end - $bss_start + $i + 1) >> 1, "\xf3\xab");
  die("fatal: error seeking to start: $fn\n") if (sysseek(F, 0, 0) or -1) != 0;
  die("fatal: error writing to DOS .com program: $fn\n") if (syswrite(F, $code, length($code)) or 0) != length($code);
  die("fatal: error truncating DOS .com program: $fn\n") if !truncate(F, length($s) - $i);
} elsif ($s =~ m@^[\x33\x31]\xc0\xbf..\x89\xe1\x29\xf9\xd1\xe9\xf3\xab@s) {  # xor ax, ax ++ mov di, ... ++ mov cx, sp ++ sub cx, di ++ shr cx, 1 ++ rep stosw.
  my $i = length($s);
  while (!vec($s, --$i, 8)) {}  # Skip backward over trailing NULs.
  die("fatal: error truncating DOS .com program: $fn\n") if !truncate(F, $i + 1);
} else {
  die("fatal: unsupported DOS .com program start code: $fn\n");
}

__END__
